// ***************************************************************
//  rpcdemo_config_pack   version:  1.0                         
//  ------------------------------------------------------------ 
//  This file was generated by vxgen.exe, don't manually modify.   
//  Hangzhou Zhidu Network Ltd.  (admin@zhidu.biz)               
//  Copyright (C) 2012-2024 - All Rights Reserved
// *************************************************************** 

#include "rpcdemo_inc.h"
#include "rpcdemo_config_proto.h"
#include "rpcdemo_config_pack.h"
#include <zce/zce_config.h>
#include <stdio.h>
#include "rpcdemo_config_pack.h"
#include <memory.h>
#include <string.h>
#include "zce/zxml_convertor.h"
#include "zce/zxml_node_base.h"
#include "zce/zdp_schema.h"

#ifdef _WIN32
#pragma warning(push)
#pragma warning(disable: 4100)
#endif

using namespace rpcdemo;

using namespace zdp;

struct _pack_rpcdemo_info : public zxml_node_base_pack
{
    _pack_rpcdemo_info(const rpcdemo_info& val):_val(val) {};
    int generate(char* buf, int size, const char* elem_name = 0) const
    {
        int len = 0, ret = 0;
        len = zxml_node_base_pack::generate_node_header(buf, size, (elem_name == 0) ? "rpcdemo_info" : elem_name, false); 
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;

        len = zxml_ushort_to_attr(buf, size, "threadnum", _val.threadnum);
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;

        len = zxml_uchar_to_attr(buf, size, "loglevel", _val.loglevel);
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;

        {
            len = zxml_string_to_attr(buf, size, "entry", _val.entry);
            CHECKLEN_MOVEBUF_ADDRET_DECSIZE;
        }
        len = zxml_node_base_pack::generate_node_enclose(buf, size);
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;
        len = zxml_node_base_pack::generate_node_tail(buf, size, (elem_name == 0) ? "rpcdemo_info" : elem_name, true);
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;
        return ret;

    }
    private: 
    const rpcdemo_info& _val;
};

int rpcdemo::zxml_pack(const rpcdemo_info& _t, zce_byte* buf, int size, zce_byte /*version*/, const char* elem_name)
{
    int /*len = 0, */ret = 0;
    _pack_rpcdemo_info _wrapper(_t);
    ret = _wrapper.generate((char*)buf, size, elem_name);
    return ret;
}

struct _pack_rpcdemo_server : public zxml_node_base_pack
{
    _pack_rpcdemo_server(const rpcdemo_server& val):_val(val) {};
    int generate(char* buf, int size, const char* elem_name = 0) const
    {
        int len = 0, ret = 0;
        len = zxml_node_base_pack::generate_node_header(buf, size, (elem_name == 0) ? "rpcdemo_server" : elem_name, false); 
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;

        len = zxml_node_base_pack::generate_node_enclose(buf, size);
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;
        {
            _pack_rpcdemo_info _wrapper(_val.info_);
            len = _wrapper.generate(buf, size, "rpcdemo_info"); 
            CHECKLEN_MOVEBUF_ADDRET_DECSIZE;
        }

        len = zxml_node_base_pack::generate_node_tail(buf, size, (elem_name == 0) ? "rpcdemo_server" : elem_name, true);
        CHECKLEN_MOVEBUF_ADDRET_DECSIZE;
        return ret;

    }
    private: 
    const rpcdemo_server& _val;
};

int rpcdemo::zxml_pack(const rpcdemo_server& _t, zce_byte* buf, int size, zce_byte /*version*/, const char* elem_name)
{
    int /*len = 0, */ret = 0;
    _pack_rpcdemo_server _wrapper(_t);
    ret = _wrapper.generate((char*)buf, size, elem_name);
    return ret;
}

int _unpack_rpcdemo_info::parser_attrs()
{
    {
        std::map<std::string, std::string>::const_iterator iter = attrs_map_.find("threadnum");
        if (iter == attrs_map_.end()) {
            ZCE_DEBUG((ZLOG_DEBUG, "attribute threadnum not exists\n"));
            return ZCE_ERROR_SYNTAX;
        }
        else {
            _val.threadnum = zxml_ushort_from_attr(iter->second.c_str());
        }
        _validate._validate_threadnum = true;
    }
    {
        std::map<std::string, std::string>::const_iterator iter = attrs_map_.find("loglevel");
        if (iter == attrs_map_.end()) {
            ZCE_DEBUG((ZLOG_DEBUG, "attribute loglevel not exists\n"));
            return ZCE_ERROR_SYNTAX;
        }
        else {
            _val.loglevel = zxml_uchar_from_attr(iter->second.c_str());
        }
        _validate._validate_loglevel = true;
    }
    {
        std::map<std::string, std::string>::const_iterator iter = attrs_map_.find("entry");
        if (iter == attrs_map_.end()) {
        }
        else {
            _val.entry = zxml_string_from_attr(iter->second.c_str());
        }
    }
    return 0;
} 

int _unpack_rpcdemo_info::query_child(zce_smartptr<zxml_node_base_unpack>& child_unpack_ptr, const char* name, const std::string& id)
{
    return zxml_node_base_unpack::E_CHILD_NOTEXISTS;
}

int _unpack_rpcdemo_info::query_all_child(std::vector<zce_smartptr<zxml_node_base_unpack> >& children)
{
    return 0;
}

bool _unpack_rpcdemo_info::validate()
{

    if (_validate._validate_threadnum == false) return false;
    if (_validate._validate_loglevel == false) return false;
    return true;
}

int rpcdemo::zxml_unpack(rpcdemo_info& _t, const zce_byte* buf, int size, zce_byte /*version*/) 
{
    int /*len = 0, */ret = 0;
    zce_smartptr<_unpack_rpcdemo_info> _wrapper(new _unpack_rpcdemo_info(_t, NULL, NULL, "", ""));
    ret = _wrapper->parser((char*)buf, size);
    return ret;
}

int _unpack_rpcdemo_server::parser_attrs()
{
    return 0;
} 

int _unpack_rpcdemo_server::query_child(zce_smartptr<zxml_node_base_unpack>& child_unpack_ptr, const char* name, const std::string& id)
{
    if (!strcmp(name, "rpcdemo_info"))
    { 
        child_unpack_ptr = new _unpack_rpcdemo_info(_val.info_, this, &_validate._validate_info_, "info_", ""); 
        return zxml_node_base_unpack::E_CHILD_OK;
    }
    return zxml_node_base_unpack::E_CHILD_NOTEXISTS;
}

int _unpack_rpcdemo_server::query_all_child(std::vector<zce_smartptr<zxml_node_base_unpack> >& children)
{
    children.push_back(zce_smartptr<zxml_node_base_unpack>(new _unpack_rpcdemo_info(_val.info_, this, NULL, "info_", "")));
    return 0;
}

bool _unpack_rpcdemo_server::validate()
{

    if (_validate._validate_info_ == false) return false;
    return true;
}

int rpcdemo::zxml_unpack(rpcdemo_server& _t, const zce_byte* buf, int size, zce_byte /*version*/) 
{
    int /*len = 0, */ret = 0;
    zce_smartptr<_unpack_rpcdemo_server> _wrapper(new _unpack_rpcdemo_server(_t, NULL, NULL, "", ""));
    ret = _wrapper->parser((char*)buf, size);
    return ret;
}

#ifdef _WIN32
#pragma warning(pop)
#endif
