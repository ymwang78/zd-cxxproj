// ***************************************************************
//  rpcdemo_config_pack   version:  1.0                         
//  ------------------------------------------------------------ 
//  This file was generated by vxgen.exe, don't manually modify.   
//  Hangzhou Zhidu Network Ltd.  (admin@zhidu.biz)               
//  Copyright (C) 2012-2024 - All Rights Reserved
// *************************************************************** 

#ifndef _rpcdemo_config_pack_h_
#define _rpcdemo_config_pack_h_

#include <vector>
#include <deque>
#include <string>
#include <zce/zce_object.h>
#include <zce/zxml_node_base.h>
#include <zce/zxml_node_factory.h>

namespace rpcdemo
{
    int zxml_pack(const rpcdemo_info& _t, zce_byte* buf, int size, zce_byte /*version*/, const char* elem_name);
    int zxml_pack(const rpcdemo_server& _t, zce_byte* buf, int size, zce_byte /*version*/, const char* elem_name);
    struct _unpack_rpcdemo_info : public zxml_node_base_unpack
    {
        private: //have to use ptr
        ~_unpack_rpcdemo_info() {};
        public:
        _unpack_rpcdemo_info(rpcdemo_info& val, zxml_node_base_unpack* parent, bool* validate_self, const char* var_name, const std::string& id)
        :zxml_node_base_unpack(parent, var_name, id), _val(val)
        { memset(&_validate, 0, sizeof(_validate)); _validate._validate__self__ = validate_self; };
        const rpcdemo_info& get() const { return _val; }
        virtual void validate_self() { if( _validate._validate__self__) *_validate._validate__self__ = validate(); }
        int parser_attrs();
        int query_child(zce_smartptr<zxml_node_base_unpack>& child_unpack_ptr, const char* name, const std::string& id = "");
        int query_all_child(std::vector<zce_smartptr<zxml_node_base_unpack> >& children);
        bool validate();
        private:
        struct _validate_t{
            bool* _validate__self__;
            bool _validate_threadnum;
            bool _validate_loglevel;
        } _validate;
        rpcdemo_info& _val;
    };
    typedef zce_smartptr<struct _unpack_rpcdemo_info> _unpack_rpcdemo_info_PTR;

    int zxml_unpack(rpcdemo_info& _t, const zce_byte* buf, int size, zce_byte /*version*/);
    struct _unpack_rpcdemo_server : public zxml_node_base_unpack
    {
        private: //have to use ptr
        ~_unpack_rpcdemo_server() {};
        public:
        _unpack_rpcdemo_server(rpcdemo_server& val, zxml_node_base_unpack* parent, bool* validate_self, const char* var_name, const std::string& id)
        :zxml_node_base_unpack(parent, var_name, id), _val(val)
        { memset(&_validate, 0, sizeof(_validate)); _validate._validate__self__ = validate_self; };
        const rpcdemo_server& get() const { return _val; }
        virtual void validate_self() { if( _validate._validate__self__) *_validate._validate__self__ = validate(); }
        int parser_attrs();
        int query_child(zce_smartptr<zxml_node_base_unpack>& child_unpack_ptr, const char* name, const std::string& id = "");
        int query_all_child(std::vector<zce_smartptr<zxml_node_base_unpack> >& children);
        bool validate();
        private:
        struct _validate_t{
            bool* _validate__self__;
            bool _validate_info_;
        } _validate;
        rpcdemo_server& _val;
    };
    typedef zce_smartptr<struct _unpack_rpcdemo_server> _unpack_rpcdemo_server_PTR;

    int zxml_unpack(rpcdemo_server& _t, const zce_byte* buf, int size, zce_byte /*version*/);
    class rpcdemo_config_factory : public zxml_node_factory 
    {
        public:
        rpcdemo_config_factory()
        {
        };
    };

    template<typename T>
    class rpcdemo_config_proc : public zxml_proc
    {
        public:
        void protocol_proc_tpl(unsigned short msgtype, const zce_object_ptr& ctx, const zce_object_ptr& root)
        {
            switch (msgtype)
            { 
                default: break;
            };
        };
    };

} //namespace rpcdemo
#endif //_rpcdemo_config_pack_h_
