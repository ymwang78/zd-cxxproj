// ***************************************************************
//  zdp_base_proto
//  ---------------------------------------------------------------
//  This file was generated by zgen, don't manually modify.
//  Yongming Wang(wangym@gmail.com)
//  Copyright (C) 2023 - All Rights Reserved
// *****************************************************************

#pragma once

#include <zce/zce_config.h>
#include <zce/zce_object.h>
#include <zce/zce_types.h>
#include <zce/zce_any.h>

namespace zdp_base
{
    struct zds_context_t;
    enum ERV_ZDP_ERRO: int
    {
        ZDP_ERRO_BASE = (int)0x80001000,
        ZDP_ERRO_NOTFOUND = (int)0x80001001,
        ZDP_ERRO_BADSERVICE = (int)0x80001002,
        ZDP_ERRO_BADARG = (int)0x80001003,
        ZDP_ERRO_BADPRIV = (int)0x80001004,
        ZDP_ERRO_BADAUTH = (int)0x80001005,
    };

    enum ERV_ZDP_PAYLOAD: int
    {
        ZDP_PAYLOAD_UNKNOW = (int)0x00000000,
        ZDP_PAYLOAD_STRING = (int)0x00000001,
        ZDP_PAYLOAD_JSON = (int)0x00000002,
        ZDP_PAYLOAD_BSON = (int)0x00000003,
        ZDP_PAYLOAD_PROTOBUF = (int)0x00000004,
    };

    enum MSG_E: int
    {
        E_MSG_NONE_REQ = (int)0x00000000,
        E_MSG_DISCONN_REQ = (int)0x00000004,
        E_MSG_CONTAINER_REQ = (int)0x00000006,
        E_MSG_CONTAINER_RES = (int)0x00000007,
        E_MSG_RPCCALL_REQ = (int)0x00000008,
        E_MSG_RPCCALL_RES = (int)0x00000009,
    };

    struct zdp_addr_t
    {
        static zdp_addr_t _empty;

        bool operator==(const zdp_addr_t& _t) const noexcept
        {
            if (translayer != _t.translayer) return false;
            if (ipclass != _t.ipclass) return false;
            if (port != _t.port) return false;
            if (addr != _t.addr) return false;
            return true;
        }

        zce_byte    translayer;
        zce_byte    ipclass;
        zce_uint16    port;
        zce_astring addr;
    };
    struct zdp_container_t
    {
        static zdp_container_t _empty;

        bool operator==(const zdp_container_t& _t) const noexcept
        {
            if (subcmd != _t.subcmd) return false;
            if (payload != _t.payload) return false;
            if (i64arg != _t.i64arg) return false;
            if (content != _t.content) return false;
            return true;
        }

        zce_int16    subcmd;
        zce_int16    payload/*ERV_ZDP_PAYLOAD*/;
        zce_int64    i64arg;
        std::vector<zce_byte> content;
    };
    struct nspair_t
    {
        static nspair_t _empty;
        zce_astring name/*名*/;
        zce_astring value/*值*/;
    };
    struct nipair_t
    {
        static nipair_t _empty;

        bool operator==(const nipair_t& _t) const noexcept
        {
            if (name != _t.name) return false;
            if (value != _t.value) return false;
            return true;
        }

        zce_astring name/*名*/;
        zce_int32    value/*值*/;
    };
    struct nllpair_t
    {
        static nllpair_t _empty;

        bool operator==(const nllpair_t& _t) const noexcept
        {
            if (name != _t.name) return false;
            if (value != _t.value) return false;
            return true;
        }

        zce_astring name/*名*/;
        zce_int64    value/*值*/;
    };
    struct zobject_proxy_t
    {
        static zobject_proxy_t _empty;

        bool operator==(const zobject_proxy_t& _t) const noexcept
        {
            if (objtype != _t.objtype) return false;
            if (objid != _t.objid) return false;
            if (svcname != _t.svcname) return false;
            if (host != _t.host) return false;
            if (port != _t.port) return false;
            if (keepalive != _t.keepalive) return false;
            if (dummy != _t.dummy) return false;
            return true;
        }

        zce_astring objtype;
        zce_int64    objid;
        zce_astring svcname;
        zce_astring host;
        zce_uint16    port;
        zce_byte    keepalive;
        zce_byte    dummy;
    };
    struct MSG_NONE_REQ : public zce_object
    {
        const static unsigned short MSG_TYPE = E_MSG_NONE_REQ;
        static const char* type_name() { return ("MSG_NONE_REQ");}
        static MSG_NONE_REQ _empty;
        std::vector<nspair_t> ie_ns;
    };
    typedef zce_smartptr<MSG_NONE_REQ> MSG_NONE_REQ_PTR;

    struct MSG_DISCONN_REQ : public zce_object
    {
        const static unsigned short MSG_TYPE = E_MSG_DISCONN_REQ;
        static const char* type_name() { return ("MSG_DISCONN_REQ");}
        static MSG_DISCONN_REQ _empty;
    };
    typedef zce_smartptr<MSG_DISCONN_REQ> MSG_DISCONN_REQ_PTR;

    struct MSG_CONTAINER_REQ : public zce_object
    {
        const static unsigned short MSG_TYPE = E_MSG_CONTAINER_REQ;
        static const char* type_name() { return ("MSG_CONTAINER_REQ");}
        static MSG_CONTAINER_REQ _empty;
        zdp_container_t    ie_req;
    };
    typedef zce_smartptr<MSG_CONTAINER_REQ> MSG_CONTAINER_REQ_PTR;

    struct MSG_CONTAINER_RES : public zce_object
    {
        const static unsigned short MSG_TYPE = E_MSG_CONTAINER_RES;
        static const char* type_name() { return ("MSG_CONTAINER_RES");}
        static MSG_CONTAINER_RES _empty;

        bool operator==(const MSG_CONTAINER_RES& _t) const noexcept
        {
            if (ie_result != _t.ie_result) return false;
            if (!(ie_res == _t.ie_res)) return false;
            return true;
        }

        zce_int32    ie_result;
        std::vector<zdp_container_t> ie_res;
    };
    typedef zce_smartptr<MSG_CONTAINER_RES> MSG_CONTAINER_RES_PTR;

    struct MSG_RPCCALL_REQ : public zce_object
    {
        const static unsigned short MSG_TYPE = E_MSG_RPCCALL_REQ;
        static const char* type_name() { return ("MSG_RPCCALL_REQ");}
        static MSG_RPCCALL_REQ _empty;

        bool operator==(const MSG_RPCCALL_REQ& _t) const noexcept
        {
            if (!(target == _t.target)) return false;
            if (method != _t.method) return false;
            if (payload != _t.payload) return false;
            return true;
        }

        zobject_proxy_t    target;
        zce_astring method;
        std::vector<zce_byte> payload;
    };
    typedef zce_smartptr<MSG_RPCCALL_REQ> MSG_RPCCALL_REQ_PTR;

    struct MSG_RPCCALL_RES : public zce_object
    {
        const static unsigned short MSG_TYPE = E_MSG_RPCCALL_RES;
        static const char* type_name() { return ("MSG_RPCCALL_RES");}
        static MSG_RPCCALL_RES _empty;

        bool operator==(const MSG_RPCCALL_RES& _t) const noexcept
        {
            if (ie_result != _t.ie_result) return false;
            if (payload != _t.payload) return false;
            return true;
        }

        zce_int32    ie_result;
        std::vector<zce_byte> payload;
    };
    typedef zce_smartptr<MSG_RPCCALL_RES> MSG_RPCCALL_RES_PTR;

} //namespace zdp_base
